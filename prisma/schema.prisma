// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// NOTES:
// ids  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
// createdAt         DateTime            @default(now()) @map("created_at")
// updatedAt         DateTime            @default(now()) @updatedAt @map("updated_at")

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["jsonProtocol", "extendedWhereUnique"]
}

//  generate zod schemas by model
// https://github.com/chrishoermann/zod-prisma-types
generator zod {
  provider = "zod-prisma-types"
  output   = "./zod" // default is ./generated/zod
}

datasource db {
  provider = "postgresql"
  // NOTE: When using postgresql, mysql or sqlserver, uncomment the @db.Text annotations in model Account below
  // Further reading:
  // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
  // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
  url      = env("DATABASE_URL")
}

// Necessary for Next auth, DO NOT CHANGE THIS!
model Account {
  id                String  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  userId            String  @map("user_id") @db.Uuid
  type              String
  provider          String
  providerAccountId String  @map("provider_account_id")
  refresh_token     String? @map("refresh_token") @db.Text
  access_token      String? @map("access_token") @db.Text
  expires_at        Int?    @map("expires_at")
  token_type        String? @map("token_type")
  scope             String?
  id_token          String? @map("id_token") @db.Text
  session_state     String? @map("session_state")
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@map("account")
}

model Session {
  id           String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  sessionToken String   @unique @map("session_token")
  userId       String   @map("user_id") @db.Uuid
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("session")
}

enum UserType {
  RECRUITER
  CANDIDATE
}

model User {
  id                  String        @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name                String?
  email               String?       @unique
  emailVerified       DateTime?     @map("email_verified")
  completedOnboarding Boolean       @default(false) @map("completed_onboarding")
  image               String?
  accounts            Account[]
  sessions            Session[]
  createdAssessments  Assessment[]
  memberships         Membership[]
  type                UserType?     @map("type") //TODO: we are not discriminating by type yet
  candidate           Candidate?
  activeOrgId         String?       @db.Uuid
  activeOrg           Organization? @relation(fields: [activeOrgId], references: [id])
  createdCandidates   Candidate[]   @relation("userCandidateCreated")

  @@map("user")
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
  @@map("verification_token")
}

model Organization {
  id          String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name        String
  slug        String?      @unique
  logo        String?
  bio         String?
  size        String?
  members     Membership[]
  assessments Assessment[]
  candidates  Candidate[]
  createdAt   DateTime     @default(now()) @map("created_at")
  updatedAt   DateTime     @default(now()) @updatedAt @map("updated_at")
  User        User[]

  @@map("organization")
}

enum MembershipRole {
  MEMBER
  HIRING_MANAGER
  RECRUITER
  ADMIN
  OWNER
}

model Membership {
  userId         String         @map("user_id") @db.Uuid
  accepted       Boolean        @default(false)
  role           MembershipRole @map("role")
  organization   Organization   @relation(fields: [organizationId], references: [id])
  organizationId String         @map("organization_id") @db.Uuid
  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([userId, organizationId])
  @@map("membership")
}

// TODO: DEFINE STATUS
enum CandidateStatus {
  PENDING
  ACCEPTED
  VERIFIED
  ARCHIVED
}

model Candidate {
  id                 String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  user               User?               @relation(fields: [userId], references: [id])
  userId             String?             @unique @map("user_id") @db.Uuid
  organizationId     String?             @map("organization_id") @db.Uuid
  assessmentSessions AssessmentSession[]
  organization       Organization?       @relation(fields: [organizationId], references: [id])
  assessments        Assessment[]
  // assessmentId       String?             @map("assessment_id") @db.Uuid
  name               String
  ghUsername         String?             @map("gh_username")
  status             CandidateStatus     @default(PENDING) @map("status")
  lastName           String              @map("last_name")
  email              String              @unique
  createdAt          DateTime            @default(now()) @map("created_at")
  updatedAt          DateTime            @default(now()) @updatedAt @map("updated_at")
  createdBy          User?               @relation("userCandidateCreated", fields: [createdById], references: [id])
  createdById        String?             @map("created_by_id") @db.Uuid
  contributions      Contribution[]
  Submission         Submission[]

  @@unique([id, email, organizationId])
  @@map("candidate")
}

enum AssessmentStatus {
  DRAFT
  ACTIVE // ready to accept candidates
  IN_PROGRESS // with active candidates 
  CLOSED // no longer accepting candidates
  ARCHIVED // deleted
}

enum Visibility {
  PUBLIC
  PRIVATE
  PROTECTED
}

model Assessment {
  id                 String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  title              String
  slug               String?
  description        String
  status             AssessmentStatus    @default(DRAFT) @map("status")
  createdBy          User                @relation(fields: [createdById], references: [id])
  createdById        String              @map("created_by_id") @db.Uuid
  organization       Organization        @relation(fields: [organizationId], references: [id])
  organizationId     String              @map("organization_id") @db.Uuid
  candidates         Candidate[]
  applicantSessions  AssessmentSession[]
  ghIssuesQuerySeach String?             @map("gh_issues_query_seach")
  evaluationPeriod   Int                 @default(1) @map("evaluation_period")
  createdAt          DateTime            @default(now()) @map("created_at")
  updatedAt          DateTime            @default(now()) @updatedAt @map("updated_at")
  published          Boolean             @default(false)
  visibility         Visibility          @default(PUBLIC)
  Submission         Submission[]

  @@map("assessment")
}

enum AssessmentSessionStatus {
  STARTED
  FINISHED
}

model AssessmentSession {
  id           String                  @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  // TODO: handle sessions expiration
  sessionToken String                  @unique @map("session_token")
  expiresAt    DateTime                @map("expires_at")
  status       AssessmentSessionStatus @default(STARTED) @map("status")
  assessment   Assessment              @relation(fields: [assessmentId], references: [id])
  assessmentId String                  @map("assessment_id") @db.Uuid
  startedAt    DateTime                @default(now()) @map("started_at")
  finishedAt   DateTime?               @map("finished_at")
  candidate    Candidate               @relation(fields: [candidateId], references: [id])
  candidateId  String                  @map("candidate_id") @db.Uuid
  Submission   Submission[]

  @@map("assessment_session")
}

enum SubmissionState {
  COMPLETED // candidated submitted they answers
  REVIEWING // hr reviewing submissions
  APPROVED // hr approved 
  REJECTED // hr rejected 
}

model Submission {
  id                  String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  contributions       Contribution[]
  status              SubmissionState   @default(REVIEWING)
  notes               String?
  createdAt           DateTime          @default(now()) @map("created_at")
  updatedAt           DateTime          @default(now()) @updatedAt @map("updated_at")
  candidate           Candidate         @relation(fields: [candidateId], references: [id])
  candidateId         String            @map("candidate_id") @db.Uuid
  session             AssessmentSession @relation(fields: [assessmentSessionId], references: [id])
  assessmentSessionId String            @map("assessment_session_id") @db.Uuid
  assessment          Assessment        @relation(fields: [assessmentId], references: [id])
  assessmentId        String            @map("assessment_id") @db.Uuid

  @@map("submission")
}

enum ContributionType {
  PULL_REQUEST
  COMMENT
  ISSUE
}

model Contribution {
  id            String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  type          ContributionType @default(PULL_REQUEST) @map("status")
  title         String
  description   String?
  url           String
  repo          String
  meta          Json?
  submission    Submission?      @relation(fields: [submissionId], references: [id])
  submissionId  String?          @map("submission_id") @db.Uuid
  contributor   Candidate        @relation(fields: [contributorId], references: [id])
  contributorId String           @map("candidate_id") @db.Uuid

  @@map("contribution")
}
